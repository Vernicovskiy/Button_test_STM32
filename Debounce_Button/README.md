# Мерцание светодиодом с антидребезгом 
 Иницаиализация портов 

```C
//Светодиод
RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; //RCC on for GPIO A
GPIOA->MODER &= ~0x00000C00; /* clear pin mode */
GPIOA->MODER |= GPIO_MODER_MODER5_0; /* output mode */
//Кнопка
RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN; //RCC on for GPIO C
GPIOC->PUPDR |= GPIO_PUPDR_PUPD13_0; // pull_up
```
Антидребезговый алгоритм 

```C
uint8_t Debounce_Handler(uint32_t state){

		if (state == 0){

			if (count < ref_count){
				count++;
				return 0;
			}

			else {
					return 1;		// button pressed
				}
			}

		else {
				if (count > 0){
					count--;
					return 1;
				}

				else {

					if (state != 0){
						return 0;
					}
				}

		}

		}
```

В главном цикле опрашиваем кнопку 
```C
while(1){

			state = READ_BIT(GPIOC->IDR, GPIO_IDR_ID13);

			if (Debounce_Handler(state) == 1){
				LED_ON();
			}
			else {
				LED_OFF();
			}
		}
```
Один из основных недостатков этого алгоритма антидребезга - он постоянно опрашивает состояние кнопки. Это может привести к излишней нагрузке на процессор, особенно если частота опроса высока.

![Alt text](image.png)

Вместо этого можно использовать прерывания для реагирования на изменения состояния кнопки. Прерывания позволяют процессору “проснуться” и обработать событие только тогда, когда происходит изменение состояния, что может быть более эффективным.

В этом коде дребезг обрабатывается путем подсчета количества опросов, в которых состояние кнопки остается неизменным. Это может быть неэффективно, если частота опроса низкая или если дребезг контактов длится дольше, чем период опроса. Возможно, было бы лучше использовать таймер для измерения времени, в течение которого состояние кнопки остается стабильным, прежде чем считать, что дребезг закончился.